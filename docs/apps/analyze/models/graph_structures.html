<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.3" />
<title>EDA_miner.apps.analyze.models.graph_structures API documentation</title>
<meta name="description" content="This module collects function to traverse the ModelBuilder graph â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>EDA_miner.apps.analyze.models.graph_structures</code></h1>
</header>
<section id="section-intro">
<p>This module collects function to traverse the ModelBuilder graph.</p>
<h2 id="functions">Functions</h2>
<ul>
<li>create_pipelines: Create pipelines from cytoscape elements and a
dict that maps a node type to relevant parameters.</li>
<li>find_pipeline_input:</li>
</ul>
<h2 id="classes">Classes</h2>
<ul>
<li>Node: A class to hold data for the nodes. Validation and advanced
functionality may be added later.
Global variables:<ul>
<li>ml_options (list(dict)): The available sklearn-like classes for use
with the ModelBuilder.</li>
<li>node_options (dict): Reverse mapping of ml_options.</li>
<li>orders (dict): The vertical ordering (position) of groups of nodes.</li>
</ul>
</li>
</ul>
<p>Notes to others:
Feel free to add or modify stuff here, but be cautious. You probably
need experience with graphs and/or trees and traversal algorithms.
The current implementation (unless I'm mistaken) are Breadth-First.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;
This module collects function to traverse the ModelBuilder graph.

Functions:
    - create_pipelines: Create pipelines from cytoscape elements and a \
                        dict that maps a node type to relevant parameters.
    - find_pipeline_input:

Classes:
    - Node: A class to hold data for the nodes. Validation and advanced \
            functionality may be added later.

Global variables:
    - ml_options (list(dict)): The available sklearn-like classes for use \
                               with the ModelBuilder.
    - node_options (dict): Reverse mapping of ml_options.
    - orders (dict): The vertical ordering (position) of groups of nodes.

Notes to others:
    Feel free to add or modify stuff here, but be cautious. You probably \
    need experience with graphs and/or trees and traversal algorithms. \
    The current implementation (unless I&#39;m mistaken) are Breadth-First.
&#34;&#34;&#34;

from apps.analyze.models import pipeline_classes

import random
import numpy as np
import networkx as nx
from networkx.drawing.nx_agraph import graphviz_layout
from itertools import combinations
from collections import defaultdict


orders = {
    &#34;input&#34;: 0,
    &#34;cleaning&#34;: 1,
    &#34;features&#34;: 2,
    &#34;preprocessing&#34;: 3,
    &#34;dim_red&#34;: 4,
    &#34;models&#34;: 5,
}

# TODO: add ensemble models as last-step models (voting, ensembles, etc)
# DO NOT ADD NEURAL NETWORK MODELS YET
ml_options = [
    # Inputs
    {&#34;label&#34;: &#34;Twitter API&#34;, &#34;node_type&#34;: &#34;twitter_api&#34;,
     &#34;parent&#34;: &#34;input&#34;, &#34;func&#34;: pipeline_classes.TwitterAPI,
     &#34;url&#34;: &#34;https://i261.photobucket.com/albums/ii47/kostasmouratidis/new_name_zpsdifgtbpq.png&#34;},
    {&#34;label&#34;: &#34;Input file&#34;, &#34;node_type&#34;: &#34;input_file&#34;,
     &#34;parent&#34;: &#34;input&#34;, &#34;func&#34;: pipeline_classes.InputFile,
     &#34;url&#34;: &#34;https://i261.photobucket.com/albums/ii47/kostasmouratidis/files_zpsfykrxcb6.png&#34;},

    # Cleaners
    {&#34;label&#34;: &#34;Data Cleaner&#34;, &#34;node_type&#34;: &#34;data_cleaner&#34;,
     &#34;parent&#34;: &#34;cleaning&#34;, &#34;func&#34;: pipeline_classes.DataCleaner,
     &#34;url&#34;: &#34;https://i261.photobucket.com/albums/ii47/kostasmouratidis/Cleaning_zpss6odzhkw.png&#34;},
    {&#34;label&#34;: &#34;Fill missing: impute&#34;, &#34;node_type&#34;: &#34;simple_missing&#34;,
     &#34;parent&#34;: &#34;cleaning&#34;, &#34;func&#34;: pipeline_classes.SimpleImputer},
    {&#34;label&#34;: &#34;Fill missing: indicator&#34;, &#34;node_type&#34;: &#34;ind_missing&#34;,
     &#34;parent&#34;: &#34;cleaning&#34;, &#34;func&#34;: pipeline_classes.MissingIndicator},

    # Feature makers
    {&#34;label&#34;: &#34;Feature constructor&#34;, &#34;node_type&#34;: &#34;feat_maker&#34;,
     &#34;parent&#34;: &#34;features&#34;, &#34;func&#34;: pipeline_classes.FeatureMaker},

    # Preprocessors
    {&#34;label&#34;: &#34;Standardization&#34;, &#34;node_type&#34;: &#34;stdsc&#34;,
     &#34;parent&#34;: &#34;preprocessing&#34;, &#34;func&#34;: pipeline_classes.StandardScaler},
    {&#34;label&#34;: &#34;Bag of Words&#34;, &#34;node_type&#34;: &#34;bow&#34;,
     &#34;parent&#34;: &#34;preprocessing&#34;, &#34;func&#34;: pipeline_classes.CountVectorizer},
    {&#34;label&#34;: &#34;TF-IDF&#34;, &#34;node_type&#34;: &#34;tfidf&#34;,
     &#34;parent&#34;: &#34;preprocessing&#34;, &#34;func&#34;: pipeline_classes.TfidfVectorizer},
    {&#34;label&#34;: &#34;Min-Max scaling&#34;, &#34;node_type&#34;: &#34;minmax_scale&#34;,
     &#34;parent&#34;: &#34;preprocessing&#34;, &#34;func&#34;: pipeline_classes.MinMaxScaler},
    {&#34;label&#34;: &#34;Label Binarizer&#34;, &#34;node_type&#34;: &#34;lbinarizer&#34;,
     &#34;parent&#34;: &#34;preprocessing&#34;, &#34;func&#34;: pipeline_classes.LabelBinarizer},

    # Decomposition / Dimensionality reduction
    {&#34;label&#34;: &#34;Principal Component Analysis&#34;, &#34;node_type&#34;: &#34;pca&#34;,
     &#34;parent&#34;: &#34;dim_red&#34;, &#34;func&#34;: pipeline_classes.PCA},
    {&#34;label&#34;: &#34;Non-negative Matrix Factorization&#34;, &#34;node_type&#34;: &#34;nmf&#34;,
     &#34;parent&#34;: &#34;dim_red&#34;, &#34;func&#34;: pipeline_classes.NMF},
    {&#34;label&#34;: &#34;Truncated SVD&#34;, &#34;node_type&#34;: &#34;tsvd&#34;,
     &#34;parent&#34;: &#34;dim_red&#34;, &#34;func&#34;: pipeline_classes.TruncatedSVD},

    # models
    # Regression
    {&#34;label&#34;: &#34;Linear Regression&#34;, &#34;node_type&#34;: &#34;linr&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.LinearRegression,
     &#34;url&#34;: &#34;https://i261.photobucket.com/albums/ii47/kostasmouratidis/linear_regression_zpsdo0ngvwz.png&#34;},
    {&#34;label&#34;: &#34;SVM Regression&#34;, &#34;node_type&#34;: &#34;svr&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.SVR,
     &#34;url&#34;: &#34;https://i261.photobucket.com/albums/ii47/kostasmouratidis/svm_zpsq1mxdxbo.png&#34;},
    {&#34;label&#34;: &#34;KNN Regression&#34;, &#34;node_type&#34;: &#34;knnr&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.KNeighborsRegressor,
     &#34;url&#34;: &#34;https://i.imgur.com/U9EFqYj.png&#34;},
    {&#34;label&#34;: &#34;Decision Tree Regression&#34;, &#34;node_type&#34;: &#34;dtr&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.DecisionTreeRegressor,
     &#34;url&#34;: &#34;https://i261.photobucket.com/albums/ii47/kostasmouratidis/decision_tree_zpsuud1pf95.png&#34;},
    {&#34;label&#34;: &#34;Dummy model: regression&#34;, &#34;node_type&#34;: &#34;dummyreg&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.DummyRegressor},
    {&#34;label&#34;: &#34;Random Forests Regression&#34;, &#34;node_type&#34;: &#34;rfr&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.RandomForestRegressor,
     &#34;url&#34;: &#34;https://i261.photobucket.com/albums/ii47/kostasmouratidis/random_forests_zpsy5ixn5xw.png&#34;},
    {&#34;label&#34;: &#34;Ridge Regression&#34;, &#34;node_type&#34;: &#34;ridge&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.Ridge,
     &#34;url&#34;: &#34;https://i261.photobucket.com/albums/ii47/kostasmouratidis/ridge_regression_zpshttczfhc.png&#34;},
    {&#34;label&#34;: &#34;Lasso Regression&#34;, &#34;node_type&#34;: &#34;lasso&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.Lasso},
    # Classification
    {&#34;label&#34;: &#34;Logistic Regression&#34;, &#34;node_type&#34;: &#34;logr&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.LogisticRegression,
     &#34;url&#34;: &#34;https://i261.photobucket.com/albums/ii47/kostasmouratidis/logistic_regression_zpsspczljjr.png&#34;},
    {&#34;label&#34;: &#34;KNN Classifier&#34;, &#34;node_type&#34;: &#34;knnc&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.KNeighborsClassifier,
     &#34;url&#34;: &#34;https://i.imgur.com/U9EFqYj.png&#34;},
    {&#34;label&#34;: &#34;XGBoost Classifier&#34;, &#34;node_type&#34;: &#34;xgb&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.XGBClassifier,
     &#34;url&#34;: &#34;https://i.imgur.com/x4mpozp.png&#34;},
    {&#34;label&#34;: &#34;Random Forest Classifier&#34;, &#34;node_type&#34;: &#34;rfc&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.RandomForestClassifier,
     &#34;url&#34;: &#34;https://i.imgur.com/x4mpozp.png&#34;},
    {&#34;label&#34;: &#34;Dummy model: classification&#34;, &#34;node_type&#34;: &#34;dummyclf&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.DummyClassifier},
    # Clustering
    {&#34;label&#34;: &#34;K-Means Clustering&#34;, &#34;node_type&#34;: &#34;kmc&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.KMeans,
     &#34;url&#34;: &#34;https://i261.photobucket.com/albums/ii47/kostasmouratidis/knn_zps24j2lqvu.png&#34;},
    {&#34;label&#34;: &#34;DBSCAN Clustering&#34;, &#34;node_type&#34;: &#34;dbscan&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.DBSCAN},
    {&#34;label&#34;: &#34;Birch Clustering&#34;, &#34;node_type&#34;: &#34;birch&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.Birch},
    {&#34;label&#34;: &#34;Agglomerative Clustering&#34;, &#34;node_type&#34;: &#34;agglomerative&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.AgglomerativeClustering,
     &#34;url&#34;: &#34;https://i261.photobucket.com/albums/ii47/kostasmouratidis/hierarchical_clustering_zpsqgxjunmf.png&#34;},
    # Naive Bayes models
    {&#34;label&#34;: &#34;Naive Bayes: Bernoulli&#34;, &#34;node_type&#34;: &#34;bernoulli_nb&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.BernoulliNB},
    {&#34;label&#34;: &#34;Naive Bayes: Gaussian&#34;, &#34;node_type&#34;: &#34;gauss_nb&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.GaussianNB},
    {&#34;label&#34;: &#34;Naive Bayes: Multinomial&#34;, &#34;node_type&#34;: &#34;multi_nb&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.MultinomialNB},
    # Others
    {&#34;label&#34;: &#34;Sentiment Analysis&#34;, &#34;node_type&#34;: &#34;sentiment&#34;,
     &#34;parent&#34;: &#34;models&#34;, &#34;func&#34;: pipeline_classes.SentimentAnalyzer},

]

node_options = {options[&#34;node_type&#34;]: options
                for options in ml_options}


class Node:
    &#34;&#34;&#34;
    A class to hold data for the nodes. Validation and advanced \
    functionality may be added later.

    Create the node either by supplying `options` or `node_type` and \
    a `note_id`.

        Args:
            options (dict): A cytoscape element.
            node_type (str): One of the keys of node_options.
            node_id (str): Unique node identifier.
    &#34;&#34;&#34;
    # TODO: Consider using slots, and/or refactoring the class.

    def __init__(self, *, options=None, node_type=None, node_id=None):

        if (options is None) and (node_type is None):
            raise ValueError(&#34;Provide at least one!&#34;)
        elif (options is not None) and (node_type is not None):
            raise ValueError(&#34;Provide at most one!&#34;)

        elif (node_type is not None) and (node_id is not None):
            # no options given, create a default node
            options = node_options[node_type]
            self.id = node_id
            self.func = options[&#34;func&#34;]
            self.parent = options[&#34;parent&#34;]

        elif options is not None:
            # if the data are nested, get only them
            options = options.get(&#34;data&#34;, options)
            self.id = options[&#34;id&#34;]
            self.func = node_options[options[&#34;node_type&#34;]][&#34;func&#34;]
            self.parent = node_options[options[&#34;node_type&#34;]][&#34;parent&#34;]
        else:
            raise ValueError(&#34;Something went wrong, and we need to investigate&#34;)

        self.url = node_options[options[&#34;node_type&#34;]].get(&#34;url&#34;,
                                            &#34;https://i261.photobucket.com/albums/ii47/kostasmouratidis/layers_zps6k0vkthc.png&#34;)

        self.label = options[&#34;label&#34;]

        self.node_type = options[&#34;node_type&#34;]
        self.order = orders[self.parent]

        self.options = {
            &#34;data&#34;: {
                &#34;label&#34;: self.label,
                &#34;node_type&#34;: self.node_type,
                &#34;id&#34;: self.id,
                &#34;parent&#34;: self.parent,
                &#34;url&#34;: self.url,
                &#34;func_params&#34;: options.get(&#34;func_params&#34;, {})
            },
            &#34;position&#34;: {
                &#39;x&#39;: 100 + self.order * 250,
                &#39;y&#39;: 150 + random.randint(-50, 200)
            },
            &#34;classes&#34;: &#34;withimage&#34;,
        }

    def render(self):
        return self.options


class NodeCollection:
    &#34;&#34;&#34;
    A collection of nodes with some added functionality for rendering them.

    Args:
        nodes (list(dict)): A list of Cytoscape elements.
        graph (`Graph`): The parent instance.

    Attributes:
        parent_nodes (list(dict)): Cytoscape elements that function as \
                                   parent/group nodes.
    &#34;&#34;&#34;

    # TODO: These probably need their own positioning!
    # Make them non-selectable so that the user cannot connect
    # a node to a group directly (might be revised later)
    parent_nodes = [
        {&#34;data&#34;: {&#34;label&#34;: &#34;Inputs&#34;, &#34;id&#34;: &#34;input&#34;},
         &#39;selectable&#39;: False, &#39;classes&#39;: &#34;parents&#34;},
        {&#34;data&#34;: {&#34;label&#34;: &#34;Cleaning&#34;, &#34;id&#34;: &#34;cleaning&#34;},
         &#39;selectable&#39;: False, &#39;classes&#39;: &#34;parents&#34;},
        {&#34;data&#34;: {&#34;label&#34;: &#34;User-defined features&#34;, &#34;id&#34;: &#34;features&#34;},
         &#39;selectable&#39;: False, &#39;classes&#39;: &#34;parents&#34;},
        {&#34;data&#34;: {&#34;label&#34;: &#34;Preprocessing&#34;, &#34;id&#34;: &#34;preprocessing&#34;},
         &#39;selectable&#39;: False, &#39;classes&#39;: &#34;parents&#34;},
        {&#34;data&#34;: {&#34;label&#34;: &#34;Dimensionality Reduction&#34;, &#34;id&#34;: &#34;dim_red&#34;},
         &#39;selectable&#39;: False, &#39;classes&#39;: &#34;parents&#34;},
        {&#34;data&#34;: {&#34;label&#34;: &#34;Estimators&#34;, &#34;id&#34;: &#34;models&#34;},
         &#39;selectable&#39;: False, &#39;classes&#39;: &#34;parents&#34;},
    ]

    def __init__(self, nodes=[], graph=None):
        self.node_max = {node_type: f&#34;{node_type}_000&#34;
                         for node_type in node_options}
        self.nodes = []
        self.graph = graph

        self.group_counts = defaultdict(int)

        # If nodes are given, parse them into an internal
        # representation and increase the relevant counts
        # (nodes originally are dictionaries of attributes)
        for n in nodes:
            node = Node(options=n)

            # keep the maximum id (e.g. &#39;linr_002&#39;)
            self.node_max[node.node_type] = max(self.node_max[node.node_type],
                                                node.id)
            self.nodes.append(node)
            self.group_counts[node.parent] += 1

    def add_node(self, node_type):
        &#34;&#34;&#34;
        Add a new node given a node_type. Generate the ID based on \
        the previous max for ID for the selected node type.

        Args:
            node_type(str): One of the keys of node_options.

        Returns:
            None
        &#34;&#34;&#34;

        max_id = self.node_max[node_type]
        node_id = f&#34;{node_type}_{str(int(max_id[-3:]) + 1).zfill(3)}&#34;

        new_node = Node(node_type=node_type, node_id=node_id)
        self.nodes.append(new_node)

        self.group_counts[new_node.parent] += 1

    def remove_node(self, node_id):
        &#34;&#34;&#34;
        Remove a node and its edges.

        Args:
            node_id (str): ID of the node to be removed.

        Returns:
            None

        Notes on implementation:
            Consider whether connecting the nodes that were connected to \
            the removed node.
        &#34;&#34;&#34;

        to_be_removed = [n for n in self.nodes if n.id == node_id]

        if len(to_be_removed):
            self.nodes.remove(to_be_removed[0])

            # Also removed edges that this node is connected to (but don&#39;t)
            # reconnect, let the user do it (for now at least)
            self.graph.edge_collection.edges = [
                edge for edge in self.graph.edge_collection.edges
                if ((to_be_removed[0].id != edge[&#34;data&#34;][&#34;source&#34;]) and
                    (to_be_removed[0].id != edge[&#34;data&#34;][&#34;target&#34;]))]

    def render(self):
        # Render nodes and remove parents without children
        return [node.render() for node in self.nodes] + [
            parent for parent in self.parent_nodes
            if self.group_counts[parent[&#34;data&#34;][&#34;id&#34;]] &gt; 0
        ]


class EdgeCollection:
    &#34;&#34;&#34;
    A collection of edges with some added functionality for rendering them.

    Args:
        edges (list(dict)): A list of Cytoscape elements.
        graph (`Graph`): The parent instance.
    &#34;&#34;&#34;

    def __init__(self, edges=[], graph=None):
        self.edges = edges
        self.graph = graph

    # TODO: This probably needs a better implementation
    def add_edges(self, selected):
        &#34;&#34;&#34;
        Add edges between the selected nodes.

        Args:
            selected (list(dict)): A list of Cytoscape elements.

        Returns:
            None

        Notes on implementation:
            Currently, edges take their direction according to the \
            order in which the nodes where clicked, not allowing \
            going back but allowing connections within the same level.
        &#34;&#34;&#34;

        for combination in combinations(selected, 2):
            node1 = Node(options=combination[0])
            node2 = Node(options=combination[1])

            if node1.order &gt; node2.order:
                new_edge = {&#34;data&#34;: {
                    &#34;source&#34;: node2.id,
                    &#34;target&#34;: node1.id
                }}

                self.edges.append(new_edge)

            elif node1.order &lt;= node2.order:
                new_edge = {&#34;data&#34;: {
                    &#34;source&#34;: node1.id,
                    &#34;target&#34;: node2.id
                }}

                self.edges.append(new_edge)

    def render(self):
        return self.edges


class Graph:
    &#34;&#34;&#34;
    A Graph to hold collections of nodes and edges and perform functions \
    on them.

    Args:
        elems (list(dict)): A list of Cytoscape elements.
    &#34;&#34;&#34;

    def __init__(self, elems):

        edges = [elem for elem in elems if &#34;source&#34; in elem[&#34;data&#34;]]
        # Don&#39;t add parent nodes, they will be added by default
        nodes = [elem for elem in elems if ((&#34;source&#34; not in elem[&#34;data&#34;]) and
                                            (&#34;parent&#34; in elem[&#34;data&#34;]))]

        self.node_collection = NodeCollection(nodes, self)
        self.edge_collection = EdgeCollection(edges, self)

    def render_graph(self):
        &#34;&#34;&#34;
        Calculates positions for all nodes in the graph and render it.

        Returns:
            list(dict): A list of Cytoscape elements.
        &#34;&#34;&#34;

        # TODO: find a better way to estimate positions
        # Convert to networkx so we can use its functionality
        # for determining positions
        nx_graph = nx.DiGraph()
        for node in self.node_collection.nodes:
            nx_graph.add_node(node.id)
        for edge in self.edge_collection.edges:
            nx_graph.add_edge(edge[&#34;data&#34;][&#34;source&#34;], edge[&#34;data&#34;][&#34;target&#34;])

        # We then use it to get min/max values.
        # The intended use to use it for more, but
        # it seems to be causing many overlaps
        positions = graphviz_layout(nx_graph)
        x_values, y_values = zip(*positions.values())
        x_max = max(x_values) + 100
        x_min = min(x_values) - 100

        # A dictionary that holds value counts of elements sharing
        # the same level / parent
        Ys = {}
        # linspace for how many different parents exist
        n_levels = 5
        widths = np.linspace(20, 700, n_levels + 1)
        for node in self.node_collection.nodes:
            # the horizontal position depends only
            # on which is the parent
            x = widths[node.order]

            # the vertical position depends only
            # on how many elements share the same parent
            Ys[node.order] = Ys.get(node.order, 0) + 1
            y = (n_levels - Ys[node.order]) * (x_max - x_min)

            # for every second parent make all elements go
            # a bit higher to avoid arrows to pass through
            # unconnected nodes
            if node.order % 2 == 0:
                y -= 50

            # this fix is necessary due to our viewport
            node.options[&#34;position&#34;] = {&#34;x&#34;: x * 2,
                                        &#34;y&#34;: y / 2}

        # TODO: Remove parents that don&#39;t have children
        return self.node_collection.render() + self.edge_collection.render()


class GraphUtils:
    &#34;&#34;&#34;
    To be used for default layouts. This definitely needs a better \
    implementation to be able to handle more advanced pipelines, and/or \
    provide better interface.

    Args:
        steps (list(tuples): Pipeline steps in the following format: \
                             (order, node_type, description).
    &#34;&#34;&#34;

    def __init__(self, steps):
        self.G = Graph([])
        for step in steps:
            self.G.node_collection.add_node(step[1])
        for s1, s2 in zip(self.G.node_collection.nodes[:-1],
                          self.G.node_collection.nodes[1:]):
            self.G.edge_collection.add_edges([s1.render(), s2.render()])

    def render_graph(self):
        return self.G.render_graph()


# TODO: This probably needs to go inside GraphUtils
# Name of pipeline and list of dash.cytoscape elements
prebuilt_pipelines = {

    # Standard scaling, dimensionality reduction, model
    &#34;default&#34;: [
        (0, &#34;input_file&#34;, &#34;Input data&#34;),
        (1, &#34;data_cleaner&#34;, &#34;Data cleaning&#34;),
        (2, &#34;feat_maker&#34;, &#34;Feature Maker&#34;),
        (3, &#34;stdsc&#34;, &#34;Standardization&#34;),
        (4, &#34;pca&#34;, &#34;Principal Components Analysis&#34;),
        (5, &#34;linr&#34;, &#34;Linear Regression&#34;),
    ],

    &#34;scale_reduce_kmeans&#34;: [
        (0, &#34;input_file&#34;, &#34;Input data&#34;),
        (3, &#34;stdsc&#34;, &#34;Standardization&#34;),
        (4, &#34;pca&#34;, &#34;Principal Components Analysis&#34;),
        (5, &#34;kmc&#34;, &#34;K-Means Clustering&#34;),
    ],

    &#34;twitter_sentiment&#34;: [
        (0, &#34;twitter_api&#34;, &#34;Twitter API&#34;),
        (1, &#34;simple_missing&#34;, &#34;Fill missing: impute&#34;),
        (2, &#34;data_cleaner&#34;, &#34;Data Cleaner&#34;),
        (3, &#34;sentiment&#34;, &#34;Sentiment Analysis&#34;),
    ]

}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="EDA_miner.apps.analyze.models.graph_structures.EdgeCollection"><code class="flex name class">
<span>class <span class="ident">EdgeCollection</span></span>
<span>(</span><span>edges=[], graph=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A collection of edges with some added functionality for rendering them.</p>
<h2 id="args">Args</h2>
<p>edges (list(dict)): A list of Cytoscape elements.
graph (<a title="EDA_miner.apps.analyze.models.graph_structures.Graph" href="#EDA_miner.apps.analyze.models.graph_structures.Graph"><code>Graph</code></a>): The parent instance.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class EdgeCollection:
    &#34;&#34;&#34;
    A collection of edges with some added functionality for rendering them.

    Args:
        edges (list(dict)): A list of Cytoscape elements.
        graph (`Graph`): The parent instance.
    &#34;&#34;&#34;

    def __init__(self, edges=[], graph=None):
        self.edges = edges
        self.graph = graph

    # TODO: This probably needs a better implementation
    def add_edges(self, selected):
        &#34;&#34;&#34;
        Add edges between the selected nodes.

        Args:
            selected (list(dict)): A list of Cytoscape elements.

        Returns:
            None

        Notes on implementation:
            Currently, edges take their direction according to the \
            order in which the nodes where clicked, not allowing \
            going back but allowing connections within the same level.
        &#34;&#34;&#34;

        for combination in combinations(selected, 2):
            node1 = Node(options=combination[0])
            node2 = Node(options=combination[1])

            if node1.order &gt; node2.order:
                new_edge = {&#34;data&#34;: {
                    &#34;source&#34;: node2.id,
                    &#34;target&#34;: node1.id
                }}

                self.edges.append(new_edge)

            elif node1.order &lt;= node2.order:
                new_edge = {&#34;data&#34;: {
                    &#34;source&#34;: node1.id,
                    &#34;target&#34;: node2.id
                }}

                self.edges.append(new_edge)

    def render(self):
        return self.edges</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="EDA_miner.apps.analyze.models.graph_structures.EdgeCollection.add_edges"><code class="name flex">
<span>def <span class="ident">add_edges</span></span>(<span>self, selected)</span>
</code></dt>
<dd>
<section class="desc"><p>Add edges between the selected nodes.</p>
<h2 id="args">Args</h2>
<p>selected (list(dict)): A list of Cytoscape elements.</p>
<h2 id="returns">Returns</h2>
<p>None
Notes on implementation:
Currently, edges take their direction according to the
order in which the nodes where clicked, not allowing
going back but allowing connections within the same level.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_edges(self, selected):
    &#34;&#34;&#34;
    Add edges between the selected nodes.

    Args:
        selected (list(dict)): A list of Cytoscape elements.

    Returns:
        None

    Notes on implementation:
        Currently, edges take their direction according to the \
        order in which the nodes where clicked, not allowing \
        going back but allowing connections within the same level.
    &#34;&#34;&#34;

    for combination in combinations(selected, 2):
        node1 = Node(options=combination[0])
        node2 = Node(options=combination[1])

        if node1.order &gt; node2.order:
            new_edge = {&#34;data&#34;: {
                &#34;source&#34;: node2.id,
                &#34;target&#34;: node1.id
            }}

            self.edges.append(new_edge)

        elif node1.order &lt;= node2.order:
            new_edge = {&#34;data&#34;: {
                &#34;source&#34;: node1.id,
                &#34;target&#34;: node2.id
            }}

            self.edges.append(new_edge)</code></pre>
</details>
</dd>
<dt id="EDA_miner.apps.analyze.models.graph_structures.EdgeCollection.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def render(self):
    return self.edges</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="EDA_miner.apps.analyze.models.graph_structures.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>elems)</span>
</code></dt>
<dd>
<section class="desc"><p>A Graph to hold collections of nodes and edges and perform functions
on them.</p>
<h2 id="args">Args</h2>
<p>elems (list(dict)): A list of Cytoscape elements.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Graph:
    &#34;&#34;&#34;
    A Graph to hold collections of nodes and edges and perform functions \
    on them.

    Args:
        elems (list(dict)): A list of Cytoscape elements.
    &#34;&#34;&#34;

    def __init__(self, elems):

        edges = [elem for elem in elems if &#34;source&#34; in elem[&#34;data&#34;]]
        # Don&#39;t add parent nodes, they will be added by default
        nodes = [elem for elem in elems if ((&#34;source&#34; not in elem[&#34;data&#34;]) and
                                            (&#34;parent&#34; in elem[&#34;data&#34;]))]

        self.node_collection = NodeCollection(nodes, self)
        self.edge_collection = EdgeCollection(edges, self)

    def render_graph(self):
        &#34;&#34;&#34;
        Calculates positions for all nodes in the graph and render it.

        Returns:
            list(dict): A list of Cytoscape elements.
        &#34;&#34;&#34;

        # TODO: find a better way to estimate positions
        # Convert to networkx so we can use its functionality
        # for determining positions
        nx_graph = nx.DiGraph()
        for node in self.node_collection.nodes:
            nx_graph.add_node(node.id)
        for edge in self.edge_collection.edges:
            nx_graph.add_edge(edge[&#34;data&#34;][&#34;source&#34;], edge[&#34;data&#34;][&#34;target&#34;])

        # We then use it to get min/max values.
        # The intended use to use it for more, but
        # it seems to be causing many overlaps
        positions = graphviz_layout(nx_graph)
        x_values, y_values = zip(*positions.values())
        x_max = max(x_values) + 100
        x_min = min(x_values) - 100

        # A dictionary that holds value counts of elements sharing
        # the same level / parent
        Ys = {}
        # linspace for how many different parents exist
        n_levels = 5
        widths = np.linspace(20, 700, n_levels + 1)
        for node in self.node_collection.nodes:
            # the horizontal position depends only
            # on which is the parent
            x = widths[node.order]

            # the vertical position depends only
            # on how many elements share the same parent
            Ys[node.order] = Ys.get(node.order, 0) + 1
            y = (n_levels - Ys[node.order]) * (x_max - x_min)

            # for every second parent make all elements go
            # a bit higher to avoid arrows to pass through
            # unconnected nodes
            if node.order % 2 == 0:
                y -= 50

            # this fix is necessary due to our viewport
            node.options[&#34;position&#34;] = {&#34;x&#34;: x * 2,
                                        &#34;y&#34;: y / 2}

        # TODO: Remove parents that don&#39;t have children
        return self.node_collection.render() + self.edge_collection.render()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="EDA_miner.apps.analyze.models.graph_structures.Graph.render_graph"><code class="name flex">
<span>def <span class="ident">render_graph</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates positions for all nodes in the graph and render it.</p>
<h2 id="returns">Returns</h2>
<p>list(dict): A list of Cytoscape elements.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def render_graph(self):
    &#34;&#34;&#34;
    Calculates positions for all nodes in the graph and render it.

    Returns:
        list(dict): A list of Cytoscape elements.
    &#34;&#34;&#34;

    # TODO: find a better way to estimate positions
    # Convert to networkx so we can use its functionality
    # for determining positions
    nx_graph = nx.DiGraph()
    for node in self.node_collection.nodes:
        nx_graph.add_node(node.id)
    for edge in self.edge_collection.edges:
        nx_graph.add_edge(edge[&#34;data&#34;][&#34;source&#34;], edge[&#34;data&#34;][&#34;target&#34;])

    # We then use it to get min/max values.
    # The intended use to use it for more, but
    # it seems to be causing many overlaps
    positions = graphviz_layout(nx_graph)
    x_values, y_values = zip(*positions.values())
    x_max = max(x_values) + 100
    x_min = min(x_values) - 100

    # A dictionary that holds value counts of elements sharing
    # the same level / parent
    Ys = {}
    # linspace for how many different parents exist
    n_levels = 5
    widths = np.linspace(20, 700, n_levels + 1)
    for node in self.node_collection.nodes:
        # the horizontal position depends only
        # on which is the parent
        x = widths[node.order]

        # the vertical position depends only
        # on how many elements share the same parent
        Ys[node.order] = Ys.get(node.order, 0) + 1
        y = (n_levels - Ys[node.order]) * (x_max - x_min)

        # for every second parent make all elements go
        # a bit higher to avoid arrows to pass through
        # unconnected nodes
        if node.order % 2 == 0:
            y -= 50

        # this fix is necessary due to our viewport
        node.options[&#34;position&#34;] = {&#34;x&#34;: x * 2,
                                    &#34;y&#34;: y / 2}

    # TODO: Remove parents that don&#39;t have children
    return self.node_collection.render() + self.edge_collection.render()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="EDA_miner.apps.analyze.models.graph_structures.GraphUtils"><code class="flex name class">
<span>class <span class="ident">GraphUtils</span></span>
<span>(</span><span>steps)</span>
</code></dt>
<dd>
<section class="desc"><p>To be used for default layouts. This definitely needs a better
implementation to be able to handle more advanced pipelines, and/or
provide better interface.</p>
<h2 id="args">Args</h2>
<p>steps (list(tuples): Pipeline steps in the following format:
(order, node_type, description).</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class GraphUtils:
    &#34;&#34;&#34;
    To be used for default layouts. This definitely needs a better \
    implementation to be able to handle more advanced pipelines, and/or \
    provide better interface.

    Args:
        steps (list(tuples): Pipeline steps in the following format: \
                             (order, node_type, description).
    &#34;&#34;&#34;

    def __init__(self, steps):
        self.G = Graph([])
        for step in steps:
            self.G.node_collection.add_node(step[1])
        for s1, s2 in zip(self.G.node_collection.nodes[:-1],
                          self.G.node_collection.nodes[1:]):
            self.G.edge_collection.add_edges([s1.render(), s2.render()])

    def render_graph(self):
        return self.G.render_graph()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="EDA_miner.apps.analyze.models.graph_structures.GraphUtils.render_graph"><code class="name flex">
<span>def <span class="ident">render_graph</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def render_graph(self):
    return self.G.render_graph()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="EDA_miner.apps.analyze.models.graph_structures.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>*, options=None, node_type=None, node_id=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A class to hold data for the nodes. Validation and advanced
functionality may be added later.</p>
<p>Create the node either by supplying <code>options</code> or <code>node_type</code> and
a <code>note_id</code>.</p>
<pre><code>Args:
    options (dict): A cytoscape element.
    node_type (str): One of the keys of node_options.
    node_id (str): Unique node identifier.
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Node:
    &#34;&#34;&#34;
    A class to hold data for the nodes. Validation and advanced \
    functionality may be added later.

    Create the node either by supplying `options` or `node_type` and \
    a `note_id`.

        Args:
            options (dict): A cytoscape element.
            node_type (str): One of the keys of node_options.
            node_id (str): Unique node identifier.
    &#34;&#34;&#34;
    # TODO: Consider using slots, and/or refactoring the class.

    def __init__(self, *, options=None, node_type=None, node_id=None):

        if (options is None) and (node_type is None):
            raise ValueError(&#34;Provide at least one!&#34;)
        elif (options is not None) and (node_type is not None):
            raise ValueError(&#34;Provide at most one!&#34;)

        elif (node_type is not None) and (node_id is not None):
            # no options given, create a default node
            options = node_options[node_type]
            self.id = node_id
            self.func = options[&#34;func&#34;]
            self.parent = options[&#34;parent&#34;]

        elif options is not None:
            # if the data are nested, get only them
            options = options.get(&#34;data&#34;, options)
            self.id = options[&#34;id&#34;]
            self.func = node_options[options[&#34;node_type&#34;]][&#34;func&#34;]
            self.parent = node_options[options[&#34;node_type&#34;]][&#34;parent&#34;]
        else:
            raise ValueError(&#34;Something went wrong, and we need to investigate&#34;)

        self.url = node_options[options[&#34;node_type&#34;]].get(&#34;url&#34;,
                                            &#34;https://i261.photobucket.com/albums/ii47/kostasmouratidis/layers_zps6k0vkthc.png&#34;)

        self.label = options[&#34;label&#34;]

        self.node_type = options[&#34;node_type&#34;]
        self.order = orders[self.parent]

        self.options = {
            &#34;data&#34;: {
                &#34;label&#34;: self.label,
                &#34;node_type&#34;: self.node_type,
                &#34;id&#34;: self.id,
                &#34;parent&#34;: self.parent,
                &#34;url&#34;: self.url,
                &#34;func_params&#34;: options.get(&#34;func_params&#34;, {})
            },
            &#34;position&#34;: {
                &#39;x&#39;: 100 + self.order * 250,
                &#39;y&#39;: 150 + random.randint(-50, 200)
            },
            &#34;classes&#34;: &#34;withimage&#34;,
        }

    def render(self):
        return self.options</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="EDA_miner.apps.analyze.models.graph_structures.Node.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def render(self):
    return self.options</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="EDA_miner.apps.analyze.models.graph_structures.NodeCollection"><code class="flex name class">
<span>class <span class="ident">NodeCollection</span></span>
<span>(</span><span>nodes=[], graph=None)</span>
</code></dt>
<dd>
<section class="desc"><p>A collection of nodes with some added functionality for rendering them.</p>
<h2 id="args">Args</h2>
<p>nodes (list(dict)): A list of Cytoscape elements.
graph (<a title="EDA_miner.apps.analyze.models.graph_structures.Graph" href="#EDA_miner.apps.analyze.models.graph_structures.Graph"><code>Graph</code></a>): The parent instance.</p>
<h2 id="attributes">Attributes</h2>
<p>parent_nodes (list(dict)): Cytoscape elements that function as
parent/group nodes.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class NodeCollection:
    &#34;&#34;&#34;
    A collection of nodes with some added functionality for rendering them.

    Args:
        nodes (list(dict)): A list of Cytoscape elements.
        graph (`Graph`): The parent instance.

    Attributes:
        parent_nodes (list(dict)): Cytoscape elements that function as \
                                   parent/group nodes.
    &#34;&#34;&#34;

    # TODO: These probably need their own positioning!
    # Make them non-selectable so that the user cannot connect
    # a node to a group directly (might be revised later)
    parent_nodes = [
        {&#34;data&#34;: {&#34;label&#34;: &#34;Inputs&#34;, &#34;id&#34;: &#34;input&#34;},
         &#39;selectable&#39;: False, &#39;classes&#39;: &#34;parents&#34;},
        {&#34;data&#34;: {&#34;label&#34;: &#34;Cleaning&#34;, &#34;id&#34;: &#34;cleaning&#34;},
         &#39;selectable&#39;: False, &#39;classes&#39;: &#34;parents&#34;},
        {&#34;data&#34;: {&#34;label&#34;: &#34;User-defined features&#34;, &#34;id&#34;: &#34;features&#34;},
         &#39;selectable&#39;: False, &#39;classes&#39;: &#34;parents&#34;},
        {&#34;data&#34;: {&#34;label&#34;: &#34;Preprocessing&#34;, &#34;id&#34;: &#34;preprocessing&#34;},
         &#39;selectable&#39;: False, &#39;classes&#39;: &#34;parents&#34;},
        {&#34;data&#34;: {&#34;label&#34;: &#34;Dimensionality Reduction&#34;, &#34;id&#34;: &#34;dim_red&#34;},
         &#39;selectable&#39;: False, &#39;classes&#39;: &#34;parents&#34;},
        {&#34;data&#34;: {&#34;label&#34;: &#34;Estimators&#34;, &#34;id&#34;: &#34;models&#34;},
         &#39;selectable&#39;: False, &#39;classes&#39;: &#34;parents&#34;},
    ]

    def __init__(self, nodes=[], graph=None):
        self.node_max = {node_type: f&#34;{node_type}_000&#34;
                         for node_type in node_options}
        self.nodes = []
        self.graph = graph

        self.group_counts = defaultdict(int)

        # If nodes are given, parse them into an internal
        # representation and increase the relevant counts
        # (nodes originally are dictionaries of attributes)
        for n in nodes:
            node = Node(options=n)

            # keep the maximum id (e.g. &#39;linr_002&#39;)
            self.node_max[node.node_type] = max(self.node_max[node.node_type],
                                                node.id)
            self.nodes.append(node)
            self.group_counts[node.parent] += 1

    def add_node(self, node_type):
        &#34;&#34;&#34;
        Add a new node given a node_type. Generate the ID based on \
        the previous max for ID for the selected node type.

        Args:
            node_type(str): One of the keys of node_options.

        Returns:
            None
        &#34;&#34;&#34;

        max_id = self.node_max[node_type]
        node_id = f&#34;{node_type}_{str(int(max_id[-3:]) + 1).zfill(3)}&#34;

        new_node = Node(node_type=node_type, node_id=node_id)
        self.nodes.append(new_node)

        self.group_counts[new_node.parent] += 1

    def remove_node(self, node_id):
        &#34;&#34;&#34;
        Remove a node and its edges.

        Args:
            node_id (str): ID of the node to be removed.

        Returns:
            None

        Notes on implementation:
            Consider whether connecting the nodes that were connected to \
            the removed node.
        &#34;&#34;&#34;

        to_be_removed = [n for n in self.nodes if n.id == node_id]

        if len(to_be_removed):
            self.nodes.remove(to_be_removed[0])

            # Also removed edges that this node is connected to (but don&#39;t)
            # reconnect, let the user do it (for now at least)
            self.graph.edge_collection.edges = [
                edge for edge in self.graph.edge_collection.edges
                if ((to_be_removed[0].id != edge[&#34;data&#34;][&#34;source&#34;]) and
                    (to_be_removed[0].id != edge[&#34;data&#34;][&#34;target&#34;]))]

    def render(self):
        # Render nodes and remove parents without children
        return [node.render() for node in self.nodes] + [
            parent for parent in self.parent_nodes
            if self.group_counts[parent[&#34;data&#34;][&#34;id&#34;]] &gt; 0
        ]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="EDA_miner.apps.analyze.models.graph_structures.NodeCollection.parent_nodes"><code class="name">var <span class="ident">parent_nodes</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="EDA_miner.apps.analyze.models.graph_structures.NodeCollection.add_node"><code class="name flex">
<span>def <span class="ident">add_node</span></span>(<span>self, node_type)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a new node given a node_type. Generate the ID based on
the previous max for ID for the selected node type.</p>
<h2 id="args">Args</h2>
<p>node_type(str): One of the keys of node_options.</p>
<h2 id="returns">Returns</h2>
<p>None</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_node(self, node_type):
    &#34;&#34;&#34;
    Add a new node given a node_type. Generate the ID based on \
    the previous max for ID for the selected node type.

    Args:
        node_type(str): One of the keys of node_options.

    Returns:
        None
    &#34;&#34;&#34;

    max_id = self.node_max[node_type]
    node_id = f&#34;{node_type}_{str(int(max_id[-3:]) + 1).zfill(3)}&#34;

    new_node = Node(node_type=node_type, node_id=node_id)
    self.nodes.append(new_node)

    self.group_counts[new_node.parent] += 1</code></pre>
</details>
</dd>
<dt id="EDA_miner.apps.analyze.models.graph_structures.NodeCollection.remove_node"><code class="name flex">
<span>def <span class="ident">remove_node</span></span>(<span>self, node_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove a node and its edges.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID of the node to be removed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None
Notes on implementation:
Consider whether connecting the nodes that were connected to
the removed node.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def remove_node(self, node_id):
    &#34;&#34;&#34;
    Remove a node and its edges.

    Args:
        node_id (str): ID of the node to be removed.

    Returns:
        None

    Notes on implementation:
        Consider whether connecting the nodes that were connected to \
        the removed node.
    &#34;&#34;&#34;

    to_be_removed = [n for n in self.nodes if n.id == node_id]

    if len(to_be_removed):
        self.nodes.remove(to_be_removed[0])

        # Also removed edges that this node is connected to (but don&#39;t)
        # reconnect, let the user do it (for now at least)
        self.graph.edge_collection.edges = [
            edge for edge in self.graph.edge_collection.edges
            if ((to_be_removed[0].id != edge[&#34;data&#34;][&#34;source&#34;]) and
                (to_be_removed[0].id != edge[&#34;data&#34;][&#34;target&#34;]))]</code></pre>
</details>
</dd>
<dt id="EDA_miner.apps.analyze.models.graph_structures.NodeCollection.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def render(self):
    # Render nodes and remove parents without children
    return [node.render() for node in self.nodes] + [
        parent for parent in self.parent_nodes
        if self.group_counts[parent[&#34;data&#34;][&#34;id&#34;]] &gt; 0
    ]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="EDA_miner.apps.analyze.models" href="index.html">EDA_miner.apps.analyze.models</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="EDA_miner.apps.analyze.models.graph_structures.EdgeCollection" href="#EDA_miner.apps.analyze.models.graph_structures.EdgeCollection">EdgeCollection</a></code></h4>
<ul class="">
<li><code><a title="EDA_miner.apps.analyze.models.graph_structures.EdgeCollection.add_edges" href="#EDA_miner.apps.analyze.models.graph_structures.EdgeCollection.add_edges">add_edges</a></code></li>
<li><code><a title="EDA_miner.apps.analyze.models.graph_structures.EdgeCollection.render" href="#EDA_miner.apps.analyze.models.graph_structures.EdgeCollection.render">render</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="EDA_miner.apps.analyze.models.graph_structures.Graph" href="#EDA_miner.apps.analyze.models.graph_structures.Graph">Graph</a></code></h4>
<ul class="">
<li><code><a title="EDA_miner.apps.analyze.models.graph_structures.Graph.render_graph" href="#EDA_miner.apps.analyze.models.graph_structures.Graph.render_graph">render_graph</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="EDA_miner.apps.analyze.models.graph_structures.GraphUtils" href="#EDA_miner.apps.analyze.models.graph_structures.GraphUtils">GraphUtils</a></code></h4>
<ul class="">
<li><code><a title="EDA_miner.apps.analyze.models.graph_structures.GraphUtils.render_graph" href="#EDA_miner.apps.analyze.models.graph_structures.GraphUtils.render_graph">render_graph</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="EDA_miner.apps.analyze.models.graph_structures.Node" href="#EDA_miner.apps.analyze.models.graph_structures.Node">Node</a></code></h4>
<ul class="">
<li><code><a title="EDA_miner.apps.analyze.models.graph_structures.Node.render" href="#EDA_miner.apps.analyze.models.graph_structures.Node.render">render</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="EDA_miner.apps.analyze.models.graph_structures.NodeCollection" href="#EDA_miner.apps.analyze.models.graph_structures.NodeCollection">NodeCollection</a></code></h4>
<ul class="">
<li><code><a title="EDA_miner.apps.analyze.models.graph_structures.NodeCollection.add_node" href="#EDA_miner.apps.analyze.models.graph_structures.NodeCollection.add_node">add_node</a></code></li>
<li><code><a title="EDA_miner.apps.analyze.models.graph_structures.NodeCollection.parent_nodes" href="#EDA_miner.apps.analyze.models.graph_structures.NodeCollection.parent_nodes">parent_nodes</a></code></li>
<li><code><a title="EDA_miner.apps.analyze.models.graph_structures.NodeCollection.remove_node" href="#EDA_miner.apps.analyze.models.graph_structures.NodeCollection.remove_node">remove_node</a></code></li>
<li><code><a title="EDA_miner.apps.analyze.models.graph_structures.NodeCollection.render" href="#EDA_miner.apps.analyze.models.graph_structures.NodeCollection.render">render</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>