<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.3" />
<title>EDA_miner.utils API documentation</title>
<meta name="description" content="This module provides utilities, functions, and other code that is
meant to be used across the app. This may undergo changes soon â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>EDA_miner.utils</code></h1>
</header>
<section id="section-intro">
<p>This module provides utilities, functions, and other code that is
meant to be used across the app. This may undergo changes soon.</p>
<h2 id="functions">Functions</h2>
<ul>
<li>cleanup: Clean up after the Dash app exits.</li>
<li>create_dropdown: Create a dropdown with a title.</li>
<li>create_table: Creates a <code>dash_table.DataTable</code> given a <code>pd.DataFrame</code>.</li>
<li>encode_image: Read and base64-encode an image for the dash app.</li>
<li>get_data: Get a <code>pandas.DataFrame</code> with the specified data.</li>
<li>hard_cast_to_float: Convert to float or return 0.</li>
<li>parse_contents: Decode uploaded files and store them in Redis.</li>
<li>pretty_print_tweets: Create H5 elements from the user's Twitter
timeline.</li>
<li>redis_startup: Connect to a Redis server &amp; handle startup.
Global variables:<ul>
<li>r: A Redis connection that is used throughout the app.</li>
<li>mapping: A dict that maps tags to sklearn models meant for
creating dropdowns and used in <code>apps.analyze</code> modules.</li>
</ul>
</li>
</ul>
<p>Notes to others:
You should probably not write code here, unless you are adding
functions aimed at being used by many lower-level modules.
Some of the functions here will later be moved to lower-level
modules (e.g. <a title="EDA_miner.utils.pretty_print_tweets" href="#EDA_miner.utils.pretty_print_tweets"><code>pretty_print_tweets()</code></a>).</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides utilities, functions, and other code that is
meant to be used across the app. This may undergo changes soon.

Functions:
    - cleanup: Clean up after the Dash app exits.
    - create_dropdown: Create a dropdown with a title.
    - create_table: Creates a `dash_table.DataTable` given a `pd.DataFrame`.
    - encode_image: Read and base64-encode an image for the dash app.
    - get_data: Get a `pandas.DataFrame` with the specified data.
    - hard_cast_to_float: Convert to float or return 0.
    - parse_contents: Decode uploaded files and store them in Redis.
    - pretty_print_tweets: Create H5 elements from the user&#39;s Twitter \
                           timeline.
    - redis_startup: Connect to a Redis server &amp; handle startup.

Global variables:
    - r: A Redis connection that is used throughout the app.
    - mapping: A dict that maps tags to sklearn models meant for \
               creating dropdowns and used in `apps.analyze` modules.

Notes to others:
    You should probably not write code here, unless you are adding
    functions aimed at being used by many lower-level modules.
    Some of the functions here will later be moved to lower-level
    modules (e.g. `pretty_print_tweets`).
&#34;&#34;&#34;

import dash_html_components as html
import dash_core_components as dcc

import dash_table

from sklearn.linear_model import LinearRegression, LogisticRegression
from sklearn.svm import SVR
from sklearn.tree import DecisionTreeRegressor
from xgboost import XGBClassifier
from sklearn.cluster import KMeans, DBSCAN
from sklearn.preprocessing import StandardScaler

import pandas as pd
import feather
import numpy as np
import base64
import json
import io
import redis
import pickle
import os
import tempfile


# TODO: this needs to be replaced by the one in Model_Builder
mapping = {
    &#34;logr&#34;: LogisticRegression,
    &#34;linr&#34;: LinearRegression,
    &#34;xgb&#34;: XGBClassifier,
    &#34;dtr&#34;: DecisionTreeRegressor,
    &#34;svr&#34;: SVR,
    &#34;kmc&#34;: KMeans,
    &#34;dbscan&#34;: DBSCAN,
    &#34;stdsc&#34;: StandardScaler,
}


# TODO: Implement user_id correctly:
# create a Redis entry with all `user_id`s that
# joined the session and cleanup for each of them
# TODO: Persist data from logged in users
def cleanup(redis_conn):
    &#34;&#34;&#34;
    Clean up after the Dash app exits.

    Args:
        redis_conn: `redis.Redis` object.

    Further details:
        Flush every key stored in the Redis database. If there
        are users that have logged in and uploaded data, store
        those on disk. Also remove any static files generated
        while the server was running.
    &#34;&#34;&#34;

    print(&#34;Cleaning up...&#34;)
    redis_conn.flushdb()

    # Remove user images
    for img in os.listdir(&#34;static/images&#34;):
        if img.startswith(&#34;python_generated_ssid&#34;):
            os.remove(f&#34;static/images/{img}&#34;)


def create_dropdown(name, options, **kwargs):
    &#34;&#34;&#34;
    Create a dropdown with a title.

    Args:
        name (str): the title above the dropdown.
        options (list(dict)): dictionaries should contain keys at least \
                             the keys (label, value).
        **kwargs: keyword-value pairs. Accepts any keyword-arguments \
                  that can be passed to `dcc.Dropdown`.

    Returns:
        list: an H5 and the Dropdown.
    &#34;&#34;&#34;

    return [
        html.H5(name+&#34;:&#34;),
        dcc.Dropdown(
            options=options,
            **kwargs
        )]


def create_table(df, table_id=&#34;table&#34;):
    &#34;&#34;&#34;
    Creates a `dash_table.DataTable` given a `pandas.DataFrame`.

    Args:
        df (`pandas.DataFrame`): the data.
        table_id (str, optional): id of the table element for usage \
                                  with dash callbacks.

    Returns:
        A `dash_table.DataTable` with pagination.
    &#34;&#34;&#34;

    return dash_table.DataTable(
        id=table_id,
        columns=[{&#34;name&#34;: i, &#34;id&#34;: i} for i in df.columns],
        data=df.to_dict(&#34;rows&#34;),
        style_table={
            &#39;maxHeight&#39;: &#39;400&#39;,
            &#39;overflowY&#39;: &#39;scroll&#39;
        },
        sorting=True,
        editable=True,
        pagination_mode=&#39;fe&#39;,
        pagination_settings={
            &#34;displayed_pages&#34;: 1,
            &#34;current_page&#34;: 0,
            &#34;page_size&#34;: 10,
        },
        navigation=&#34;page&#34;,
        # n_fixed_rows=1,
        style_cell={
            &#39;width&#39;: &#39;150px&#39;,
            &#39;overflow&#39;: &#39;hidden&#39;,
            &#39;textOverflow&#39;: &#39;ellipsis&#39;,
            &#39;maxWidth&#39;: 0,
            &#39;paddingLeft&#39;: &#39;15px&#39;,
            # &#39;paddingRight&#39;: &#39;15px&#39;,
        },
        style_cell_conditional=[
            {
                &#39;if&#39;: {&#39;row_index&#39;: &#39;odd&#39;},
                &#39;backgroundColor&#39;: &#39;rgb(218, 218, 218)&#39;
            },
            {
                &#39;if&#39;: {&#39;row_index&#39;: &#39;even&#39;},
                &#39;backgroundColor&#39;: &#39;rgb(248, 248, 248)&#39;
            },
        ],
        style_header={
            &#39;backgroundColor&#39;: &#39;rgb(30, 30, 30)&#39;,
            &#39;color&#39;: &#39;rgb(230,230,230)&#39;,
            &#34;fontWeight&#34;: &#34;bold&#34;,
        },
    )


def encode_image(image_path):
    &#34;&#34;&#34;
    Read and base64-encode an image for the dash app&lt;/h2&gt;

    Args:
        image_path (str): absolute path or relative to the \
                          top-level directory

    Returns:
        A str to be used for the src attribute of an img element.
    &#34;&#34;&#34;

    return &#39;data:image/png;base64,{}&#39;.format(base64.b64encode(
        open(image_path, &#39;rb&#39;).read()).decode())


def get_data(api_choice, user_id):
    &#34;&#34;&#34;
    Get a `pandas.DataFrame` with the specified data.&lt;/h2&gt;

    Args:
        api_choice (str): the key used by the Redis server \
                          to store the data.
        user_id (str): the user for whom to fetch data.
    &#34;&#34;&#34;

    if api_choice is None:
        df = None

    elif api_choice == &#34;gsheets_api&#34;:
        df = pickle.loads(r.get(f&#34;{user_id}_{api_choice}_data&#34;))

    # uploaded data
    elif api_choice.startswith(&#34;user_data&#34;):
        df = pd.read_msgpack(r.get(f&#34;{user_id}_{api_choice}&#34;))

    elif api_choice.startswith(&#34;quandl_api&#34;):
        df = pickle.loads(r.get(f&#34;{user_id}_{api_choice}&#34;))

    else:
        df = None

    return df


def hard_cast_to_float(x):
    &#34;&#34;&#34;
    Convert to float or return 0.

    Args:
        x (anything): will be type-casted or 0&#39;ed.

    Returns:
        float.
    &#34;&#34;&#34;

    try:
        ret = np.float32(x)
    except:
        ret = 0

    return ret


# TODO: this function needs to be reviewed because
#       it doesn&#39;t work correctly on error (i.e. returns a Div).
def parse_contents(contents, filename, date, user_id):
    &#34;&#34;&#34;
    Decode uploaded files and store them in Redis.

    Args:
        contents (str): the content of the file to be decoded.
        filename (str): name of uploaded file.
        date (str): (modification?) date of the file.
        user_id (str): the user for whom to fetch data.

    Further details:
        After decoding the uploaded file, handle any remaining
        operations here. This was stolen from the dash docs. Currently
        it only supports csv, xls(x), json, and feather file types.
    &#34;&#34;&#34;

    content_type, content_string = contents.split(&#39;,&#39;)

    decoded = base64.b64decode(content_string)
    try:
        if &#39;csv&#39; in filename:
            # Assume that the user uploaded a CSV file
            df = pd.read_csv(
                io.StringIO(decoded.decode(&#39;utf-8&#39;)))
        elif &#39;xls&#39; in filename:
            # Assume that the user uploaded an excel file
            df = pd.read_excel(io.BytesIO(decoded))
        elif &#39;json&#39; in filename:
            # Assume that the user uploaded an json file
            try:
                df = pd.DataFrame.from_dict(json.loads(decoded.decode(&#39;utf-8&#39;)))
            except ValueError:
                # JSON file is probably only one row, so convert it to list
                df = pd.DataFrame.from_dict([json.loads(decoded.decode(&#39;utf-8&#39;))])
        elif &#34;feather&#34; in filename:
            # Assume that the user uploaded a feather file
            # Since this only reads from a file, we careate
            # a temporary named file
            with tempfile.NamedTemporaryFile() as tmp:
                tmp.write(decoded)
                # Pandas read_feather doesn&#39;t seem to work
                df = feather.read_dataframe(tmp.name)

        else:
            return html.Div([&#39;Format not yet supported.&#39;])

    except Exception as e:
        print(e)
        return html.Div([&#39;There was an error processing this file.&#39;])

    name = os.path.splitext(filename)[0]
    # Store to redis for caching
    r.set(f&#34;{user_id}_user_data_{name}&#34;, df.to_msgpack(compress=&#39;zlib&#39;))

    return html.Div([
        &#34;Data uploaded successfully.&#34;
    ])


def pretty_print_tweets(api, n_tweets):
    &#34;&#34;&#34;
    Create H5 elements from the user&#39;s Twitter timeline.

    Args:
        api (`twitter.Api`): a connection to Twitter \
                             with verified credentials.
        n_tweets (int): the number of tweets to display.
    &#34;&#34;&#34;

    return [
        html.H5(str(tweet.text))
        for tweet in api.GetUserTimeline()[:n_tweets]
    ]


def redis_startup():
    &#34;&#34;&#34;
    Connect to a Redis server &amp; handle startup.

    Returns:
        `redis.Redis`: a connection to a Redis server.

    Further details:
        Connects to a Redis server on its default port (6379) and
        is also responsible for any other startup operations needed.
    &#34;&#34;&#34;

    redis_conn = redis.Redis(host=&#34;localhost&#34;, port=6379, db=0)

    return redis_conn


r = redis_startup()
&#34;&#34;&#34;The Redis connection that is used throughout the app.&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="EDA_miner.utils.r"><code class="name">var <span class="ident">r</span></code></dt>
<dd>
<section class="desc"><p>The Redis connection that is used throughout the app.</p></section>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="EDA_miner.utils.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span>(<span>redis_conn)</span>
</code></dt>
<dd>
<section class="desc"><p>Clean up after the Dash app exits.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>redis_conn</code></strong></dt>
<dd><code>redis.Redis</code> object.</dd>
</dl>
<p>Further details:
Flush every key stored in the Redis database. If there
are users that have logged in and uploaded data, store
those on disk. Also remove any static files generated
while the server was running.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def cleanup(redis_conn):
    &#34;&#34;&#34;
    Clean up after the Dash app exits.

    Args:
        redis_conn: `redis.Redis` object.

    Further details:
        Flush every key stored in the Redis database. If there
        are users that have logged in and uploaded data, store
        those on disk. Also remove any static files generated
        while the server was running.
    &#34;&#34;&#34;

    print(&#34;Cleaning up...&#34;)
    redis_conn.flushdb()

    # Remove user images
    for img in os.listdir(&#34;static/images&#34;):
        if img.startswith(&#34;python_generated_ssid&#34;):
            os.remove(f&#34;static/images/{img}&#34;)</code></pre>
</details>
</dd>
<dt id="EDA_miner.utils.create_dropdown"><code class="name flex">
<span>def <span class="ident">create_dropdown</span></span>(<span>name, options, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a dropdown with a title.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>the title above the dropdown.</dd>
<dt>options (list(dict)): dictionaries should contain keys at least
the keys (label, value).</dt>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>keyword-value pairs. Accepts any keyword-arguments
that can be passed to <code>dcc.Dropdown</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>list</code></strong></dt>
<dd>an H5 and the Dropdown.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def create_dropdown(name, options, **kwargs):
    &#34;&#34;&#34;
    Create a dropdown with a title.

    Args:
        name (str): the title above the dropdown.
        options (list(dict)): dictionaries should contain keys at least \
                             the keys (label, value).
        **kwargs: keyword-value pairs. Accepts any keyword-arguments \
                  that can be passed to `dcc.Dropdown`.

    Returns:
        list: an H5 and the Dropdown.
    &#34;&#34;&#34;

    return [
        html.H5(name+&#34;:&#34;),
        dcc.Dropdown(
            options=options,
            **kwargs
        )]</code></pre>
</details>
</dd>
<dt id="EDA_miner.utils.create_table"><code class="name flex">
<span>def <span class="ident">create_table</span></span>(<span>df, table_id='table')</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a <code>dash_table.DataTable</code> given a <code>pandas.DataFrame</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt>df (<code>pandas.DataFrame</code>): the data.</dt>
<dt><strong><code>table_id</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>id of the table element for usage
with dash callbacks.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A <code>dash_table.DataTable</code> with pagination.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def create_table(df, table_id=&#34;table&#34;):
    &#34;&#34;&#34;
    Creates a `dash_table.DataTable` given a `pandas.DataFrame`.

    Args:
        df (`pandas.DataFrame`): the data.
        table_id (str, optional): id of the table element for usage \
                                  with dash callbacks.

    Returns:
        A `dash_table.DataTable` with pagination.
    &#34;&#34;&#34;

    return dash_table.DataTable(
        id=table_id,
        columns=[{&#34;name&#34;: i, &#34;id&#34;: i} for i in df.columns],
        data=df.to_dict(&#34;rows&#34;),
        style_table={
            &#39;maxHeight&#39;: &#39;400&#39;,
            &#39;overflowY&#39;: &#39;scroll&#39;
        },
        sorting=True,
        editable=True,
        pagination_mode=&#39;fe&#39;,
        pagination_settings={
            &#34;displayed_pages&#34;: 1,
            &#34;current_page&#34;: 0,
            &#34;page_size&#34;: 10,
        },
        navigation=&#34;page&#34;,
        # n_fixed_rows=1,
        style_cell={
            &#39;width&#39;: &#39;150px&#39;,
            &#39;overflow&#39;: &#39;hidden&#39;,
            &#39;textOverflow&#39;: &#39;ellipsis&#39;,
            &#39;maxWidth&#39;: 0,
            &#39;paddingLeft&#39;: &#39;15px&#39;,
            # &#39;paddingRight&#39;: &#39;15px&#39;,
        },
        style_cell_conditional=[
            {
                &#39;if&#39;: {&#39;row_index&#39;: &#39;odd&#39;},
                &#39;backgroundColor&#39;: &#39;rgb(218, 218, 218)&#39;
            },
            {
                &#39;if&#39;: {&#39;row_index&#39;: &#39;even&#39;},
                &#39;backgroundColor&#39;: &#39;rgb(248, 248, 248)&#39;
            },
        ],
        style_header={
            &#39;backgroundColor&#39;: &#39;rgb(30, 30, 30)&#39;,
            &#39;color&#39;: &#39;rgb(230,230,230)&#39;,
            &#34;fontWeight&#34;: &#34;bold&#34;,
        },
    )</code></pre>
</details>
</dd>
<dt id="EDA_miner.utils.encode_image"><code class="name flex">
<span>def <span class="ident">encode_image</span></span>(<span>image_path)</span>
</code></dt>
<dd>
<section class="desc"><p>Read and base64-encode an image for the dash app</h2></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image_path</code></strong> :&ensp;<code>str</code></dt>
<dd>absolute path or relative to the
top-level directory</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A str to be used for the src attribute of an img element.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def encode_image(image_path):
    &#34;&#34;&#34;
    Read and base64-encode an image for the dash app&lt;/h2&gt;

    Args:
        image_path (str): absolute path or relative to the \
                          top-level directory

    Returns:
        A str to be used for the src attribute of an img element.
    &#34;&#34;&#34;

    return &#39;data:image/png;base64,{}&#39;.format(base64.b64encode(
        open(image_path, &#39;rb&#39;).read()).decode())</code></pre>
</details>
</dd>
<dt id="EDA_miner.utils.get_data"><code class="name flex">
<span>def <span class="ident">get_data</span></span>(<span>api_choice, user_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Get a <code>pandas.DataFrame</code> with the specified data.</h2></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api_choice</code></strong> :&ensp;<code>str</code></dt>
<dd>the key used by the Redis server
to store the data.</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>the user for whom to fetch data.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_data(api_choice, user_id):
    &#34;&#34;&#34;
    Get a `pandas.DataFrame` with the specified data.&lt;/h2&gt;

    Args:
        api_choice (str): the key used by the Redis server \
                          to store the data.
        user_id (str): the user for whom to fetch data.
    &#34;&#34;&#34;

    if api_choice is None:
        df = None

    elif api_choice == &#34;gsheets_api&#34;:
        df = pickle.loads(r.get(f&#34;{user_id}_{api_choice}_data&#34;))

    # uploaded data
    elif api_choice.startswith(&#34;user_data&#34;):
        df = pd.read_msgpack(r.get(f&#34;{user_id}_{api_choice}&#34;))

    elif api_choice.startswith(&#34;quandl_api&#34;):
        df = pickle.loads(r.get(f&#34;{user_id}_{api_choice}&#34;))

    else:
        df = None

    return df</code></pre>
</details>
</dd>
<dt id="EDA_miner.utils.hard_cast_to_float"><code class="name flex">
<span>def <span class="ident">hard_cast_to_float</span></span>(<span>x)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert to float or return 0.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>anything</code></dt>
<dd>will be type-casted or 0'ed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>float.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hard_cast_to_float(x):
    &#34;&#34;&#34;
    Convert to float or return 0.

    Args:
        x (anything): will be type-casted or 0&#39;ed.

    Returns:
        float.
    &#34;&#34;&#34;

    try:
        ret = np.float32(x)
    except:
        ret = 0

    return ret</code></pre>
</details>
</dd>
<dt id="EDA_miner.utils.parse_contents"><code class="name flex">
<span>def <span class="ident">parse_contents</span></span>(<span>contents, filename, date, user_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Decode uploaded files and store them in Redis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>contents</code></strong> :&ensp;<code>str</code></dt>
<dd>the content of the file to be decoded.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>name of uploaded file.</dd>
<dt><strong><code>date</code></strong> :&ensp;<code>str</code></dt>
<dd>(modification?) date of the file.</dd>
<dt><strong><code>user_id</code></strong> :&ensp;<code>str</code></dt>
<dd>the user for whom to fetch data.</dd>
</dl>
<p>Further details:
After decoding the uploaded file, handle any remaining
operations here. This was stolen from the dash docs. Currently
it only supports csv, xls(x), json, and feather file types.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def parse_contents(contents, filename, date, user_id):
    &#34;&#34;&#34;
    Decode uploaded files and store them in Redis.

    Args:
        contents (str): the content of the file to be decoded.
        filename (str): name of uploaded file.
        date (str): (modification?) date of the file.
        user_id (str): the user for whom to fetch data.

    Further details:
        After decoding the uploaded file, handle any remaining
        operations here. This was stolen from the dash docs. Currently
        it only supports csv, xls(x), json, and feather file types.
    &#34;&#34;&#34;

    content_type, content_string = contents.split(&#39;,&#39;)

    decoded = base64.b64decode(content_string)
    try:
        if &#39;csv&#39; in filename:
            # Assume that the user uploaded a CSV file
            df = pd.read_csv(
                io.StringIO(decoded.decode(&#39;utf-8&#39;)))
        elif &#39;xls&#39; in filename:
            # Assume that the user uploaded an excel file
            df = pd.read_excel(io.BytesIO(decoded))
        elif &#39;json&#39; in filename:
            # Assume that the user uploaded an json file
            try:
                df = pd.DataFrame.from_dict(json.loads(decoded.decode(&#39;utf-8&#39;)))
            except ValueError:
                # JSON file is probably only one row, so convert it to list
                df = pd.DataFrame.from_dict([json.loads(decoded.decode(&#39;utf-8&#39;))])
        elif &#34;feather&#34; in filename:
            # Assume that the user uploaded a feather file
            # Since this only reads from a file, we careate
            # a temporary named file
            with tempfile.NamedTemporaryFile() as tmp:
                tmp.write(decoded)
                # Pandas read_feather doesn&#39;t seem to work
                df = feather.read_dataframe(tmp.name)

        else:
            return html.Div([&#39;Format not yet supported.&#39;])

    except Exception as e:
        print(e)
        return html.Div([&#39;There was an error processing this file.&#39;])

    name = os.path.splitext(filename)[0]
    # Store to redis for caching
    r.set(f&#34;{user_id}_user_data_{name}&#34;, df.to_msgpack(compress=&#39;zlib&#39;))

    return html.Div([
        &#34;Data uploaded successfully.&#34;
    ])</code></pre>
</details>
</dd>
<dt id="EDA_miner.utils.pretty_print_tweets"><code class="name flex">
<span>def <span class="ident">pretty_print_tweets</span></span>(<span>api, n_tweets)</span>
</code></dt>
<dd>
<section class="desc"><p>Create H5 elements from the user's Twitter timeline.</p>
<h2 id="args">Args</h2>
<dl>
<dt>api (<code>twitter.Api</code>): a connection to Twitter
with verified credentials.</dt>
<dt><strong><code>n_tweets</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of tweets to display.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def pretty_print_tweets(api, n_tweets):
    &#34;&#34;&#34;
    Create H5 elements from the user&#39;s Twitter timeline.

    Args:
        api (`twitter.Api`): a connection to Twitter \
                             with verified credentials.
        n_tweets (int): the number of tweets to display.
    &#34;&#34;&#34;

    return [
        html.H5(str(tweet.text))
        for tweet in api.GetUserTimeline()[:n_tweets]
    ]</code></pre>
</details>
</dd>
<dt id="EDA_miner.utils.redis_startup"><code class="name flex">
<span>def <span class="ident">redis_startup</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Connect to a Redis server &amp; handle startup.</p>
<h2 id="returns">Returns</h2>
<p><code>redis.Redis</code>: a connection to a Redis server.
Further details:
Connects to a Redis server on its default port (6379) and
is also responsible for any other startup operations needed.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def redis_startup():
    &#34;&#34;&#34;
    Connect to a Redis server &amp; handle startup.

    Returns:
        `redis.Redis`: a connection to a Redis server.

    Further details:
        Connects to a Redis server on its default port (6379) and
        is also responsible for any other startup operations needed.
    &#34;&#34;&#34;

    redis_conn = redis.Redis(host=&#34;localhost&#34;, port=6379, db=0)

    return redis_conn</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="EDA_miner" href="index.html">EDA_miner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="EDA_miner.utils.r" href="#EDA_miner.utils.r">r</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="EDA_miner.utils.cleanup" href="#EDA_miner.utils.cleanup">cleanup</a></code></li>
<li><code><a title="EDA_miner.utils.create_dropdown" href="#EDA_miner.utils.create_dropdown">create_dropdown</a></code></li>
<li><code><a title="EDA_miner.utils.create_table" href="#EDA_miner.utils.create_table">create_table</a></code></li>
<li><code><a title="EDA_miner.utils.encode_image" href="#EDA_miner.utils.encode_image">encode_image</a></code></li>
<li><code><a title="EDA_miner.utils.get_data" href="#EDA_miner.utils.get_data">get_data</a></code></li>
<li><code><a title="EDA_miner.utils.hard_cast_to_float" href="#EDA_miner.utils.hard_cast_to_float">hard_cast_to_float</a></code></li>
<li><code><a title="EDA_miner.utils.parse_contents" href="#EDA_miner.utils.parse_contents">parse_contents</a></code></li>
<li><code><a title="EDA_miner.utils.pretty_print_tweets" href="#EDA_miner.utils.pretty_print_tweets">pretty_print_tweets</a></code></li>
<li><code><a title="EDA_miner.utils.redis_startup" href="#EDA_miner.utils.redis_startup">redis_startup</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>